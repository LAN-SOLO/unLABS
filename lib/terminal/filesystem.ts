// _unOS Virtual Filesystem
// In-memory Unix-like filesystem for the terminal interface

export interface VirtualNode {
  name: string
  type: 'file' | 'dir' | 'symlink'
  content?: string
  children?: Map<string, VirtualNode>
  permissions: number // octal, e.g. 0o755
  owner: string
  group: string
  modified: number
  size: number
  target?: string // symlink target
}

export class VirtualFS {
  root: VirtualNode
  private _cwd: string = '/home/operator'
  private _previousCwd: string = '/home/operator'

  constructor() {
    this.root = this.buildDefaultTree()
  }

  get cwd(): string {
    return this._cwd
  }

  private mknode(
    name: string,
    type: 'file' | 'dir' | 'symlink',
    opts: {
      content?: string
      permissions?: number
      owner?: string
      group?: string
      target?: string
    } = {}
  ): VirtualNode {
    const now = Date.now()
    const node: VirtualNode = {
      name,
      type,
      permissions: opts.permissions ?? (type === 'dir' ? 0o755 : 0o644),
      owner: opts.owner ?? 'root',
      group: opts.group ?? 'root',
      modified: now,
      size: opts.content?.length ?? 0,
    }
    if (type === 'dir') {
      node.children = new Map()
    }
    if (opts.content !== undefined) {
      node.content = opts.content
    }
    if (opts.target) {
      node.target = opts.target
    }
    return node
  }

  private addChild(parent: VirtualNode, child: VirtualNode): VirtualNode {
    parent.children!.set(child.name, child)
    return child
  }

  private buildDefaultTree(): VirtualNode {
    const root = this.mknode('/', 'dir', { permissions: 0o755 })

    // /bin
    const bin = this.addChild(root, this.mknode('bin', 'dir'))
    for (const cmd of ['ls', 'cd', 'cat', 'mkdir', 'touch', 'rm', 'chmod', 'chown', 'pwd', 'echo', 'tree', 'clear', 'su', 'sudo', 'passwd', 'id', 'groups', 'whoami', 'useradd']) {
      this.addChild(bin, this.mknode(cmd, 'file', { permissions: 0o755, content: `#!/bin/sh\n# ${cmd} - _unOS builtin` }))
    }

    // /etc
    const etc = this.addChild(root, this.mknode('etc', 'dir'))
    const etcUnos = this.addChild(etc, this.mknode('_unOS', 'dir'))
    this.addChild(etcUnos, this.mknode('lab.conf', 'file', {
      content: [
        '# _unOS Laboratory Configuration',
        '# Generated by _unLAB installer v2.1.0',
        '',
        '[general]',
        'lab_name = _unLAB',
        'lab_id = UL-0001',
        'version = 2.1.0',
        'mode = DEVELOPER',
        '',
        '[crystals]',
        'max_crystals = 100',
        'slices_per_crystal = 30',
        'auto_stabilize = true',
        '',
        '[economy]',
        'token = _unSC',
        'mint_cost = 50',
        'network = solana-devnet',
        '',
        '[security]',
        'level = MAXIMUM',
        'encryption = AES-256',
        'session_timeout = 3600',
      ].join('\n'),
    }))
    this.addChild(etcUnos, this.mknode('blockchain.conf', 'file', {
      content: [
        '# Blockchain Configuration',
        '',
        '[network]',
        'chain = solana',
        'cluster = devnet',
        'rpc_url = https://api.devnet.solana.com',
        'ws_url = wss://api.devnet.solana.com',
        '',
        '[volatility]',
        'tracking = enabled',
        'sample_interval = 5000',
        'tier_thresholds = 500,1500,3000,4500',
        '',
        '[tokens]',
        'program_id = UnSC...redacted',
        'mint_authority = system',
      ].join('\n'),
    }))

    const etcScrewButtons = this.addChild(etcUnos, this.mknode('screwbuttons', 'dir'))
    for (const [id, conf] of [
      ['sb01', 'SB-01|NODE-SYNC|top-left|enabled'],
      ['sb02', 'SB-02|POOL-LINK|top-right|enabled'],
      ['sb03', 'SB-03|MESH-CAST|bottom-left|enabled'],
      ['sb04', 'SB-04|QUANTUM-BRIDGE|bottom-right|enabled'],
    ]) {
      this.addChild(etcScrewButtons, this.mknode(`${id}.conf`, 'file', {
        content: `# Screw Button Configuration\n# Auto-generated by _unOS\n${conf}\n`,
      }))
    }

    this.addChild(etc, this.mknode('passwd', 'file', {
      permissions: 0o644,
      content: [
        'root:x:0:0:root:/root:/bin/sh',
        'adm:x:1000:1000:Lab Administrator:/home/adm:/bin/sh',
        'operator:x:1001:1001:Lab Operator:/home/operator:/bin/sh',
      ].join('\n'),
    }))

    this.addChild(etc, this.mknode('shadow', 'file', {
      permissions: 0o600,
      content: [
        'root:$6$rounds=656000$locked::0:99999:7:::',
        'adm:$6$rounds=656000$hashed_placeholder::0:99999:7:::',
        'operator:$6$rounds=656000$hashed_placeholder::0:99999:7:::',
      ].join('\n'),
    }))

    this.addChild(etc, this.mknode('group', 'file', {
      content: [
        'root:x:0:root',
        'wheel:x:10:adm',
        'sudo:x:27:adm',
        'adm:x:1000:adm',
        'operator:x:1001:operator',
        'games:x:1002:operator',
      ].join('\n'),
    }))

    this.addChild(etc, this.mknode('hostname', 'file', {
      content: '_unLAB',
    }))

    this.addChild(etc, this.mknode('motd', 'file', {
      content: [
        '',
        '  ██╗   ██╗███╗   ██╗ ██████╗ ███████╗',
        '  ██║   ██║████╗  ██║██╔═══██╗██╔════╝',
        '  ██║   ██║██╔██╗ ██║██║   ██║███████╗',
        '  ██║   ██║██║╚██╗██║██║   ██║╚════██║',
        '  ╚██████╔╝██║ ╚████║╚██████╔╝███████║',
        '   ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚══════╝',
        '',
        '  Welcome to _unOS v2.1.0 (Quantum Kernel 6.1.0-_unSC)',
        '  Last login: session start',
        '',
      ].join('\n'),
    }))

    // /home
    const home = this.addChild(root, this.mknode('home', 'dir'))

    // /home/operator
    const opHome = this.addChild(home, this.mknode('operator', 'dir', { owner: 'operator', group: 'operator', permissions: 0o750 }))
    this.addChild(opHome, this.mknode('.bashrc', 'file', {
      owner: 'operator', group: 'operator',
      content: '# _unOS operator shell config\nexport PS1="\\u@_unLAB:\\w$ "\nexport PATH=/bin:/usr/bin\n',
    }))
    this.addChild(opHome, this.mknode('.profile', 'file', {
      owner: 'operator', group: 'operator',
      content: '# operator profile\necho "Welcome, operator."\n',
    }))
    // .local/docs - device documentation
    const opLocal = this.addChild(opHome, this.mknode('.local', 'dir', { owner: 'operator', group: 'operator' }))
    const opLocalDocs = this.addChild(opLocal, this.mknode('docs', 'dir', { owner: 'operator', group: 'operator' }))
    this.addChild(opLocalDocs, this.mknode('emc001.txt', 'file', {
      owner: 'operator', group: 'operator',
      content: [
        '═══════════════════════════════════════════════════════════',
        '  EMC-001 :: EXOTIC MATTER CONTAINMENT',
        '  Device Specification v4.0',
        '═══════════════════════════════════════════════════════════',
        '',
        'OVERVIEW',
        '  High-energy containment field for exotic matter particles.',
        '  Magnetic confinement system (CERN-class) with real-time',
        '  monitoring of particle count, stability, and field strength.',
        '',
        'SPECIFICATIONS',
        '  Device ID:     EMC-001',
        '  Firmware:      v4.0.1 (build 2026.01.15)',
        '  Checksum:      E8X4M2C7',
        '  Particles:     42 units (max capacity)',
        '  Field Type:    Magnetic confinement',
        '  Temperature:   800-1200°K (operational)',
        '',
        'POWER',
        '  Full:          40 E/s',
        '  Idle:          18 E/s',
        '  Standby:       2 E/s',
        '  Scan/Test:     55 E/s',
        '  Category:      Heavy',
        '  Priority:      P1 (Critical)',
        '',
        'FEATURES',
        '  - containment-field : Magnetic confinement barrier',
        '  - particle-tracking : Real-time particle position monitor',
        '  - stability-calc    : Containment stability percentage',
        '  - matter-compress   : Exotic matter compression system',
        '  - field-harmonics   : Field resonance harmonics',
        '',
        'COMMANDS',
        '  emc status           Show containment status',
        '  emc power [on|off]   Power on/off containment field',
        '  emc firmware         View firmware info',
        '  emc firmware update  Check for firmware updates',
        '  emc test             Run containment diagnostics',
        '  emc reset            Reboot containment system',
        '  emc info             Show this documentation',
        '',
        'BOOT SEQUENCE',
        '  1. field       - Generate containment field',
        '  2. containment - Establish magnetic boundary',
        '  3. particles   - Load exotic matter particles',
        '  4. stabilize   - Stabilize field harmonics',
        '  5. ready       - Containment online',
        '',
        'SHUTDOWN SEQUENCE',
        '  1. decontain   - Release field pressure',
        '  2. collapse    - Collapse containment barrier',
        '  3. cooldown    - Thermal stabilization',
        '',
        'TROUBLESHOOTING',
        '  - Low stability: check field strength and temperature',
        '  - Field collapse: immediate reboot with emc reset',
        '  - If containment offline, run: emc power on',
        '  - Run emc test to verify all containment systems',
        '  - High temperature (>1100°K): monitor closely',
        '',
        'COMPATIBLE DEVICES',
        '  MFR-001  Microfusion Reactor (power source)',
        '  QAN-001  Quantum Analyzer (quantum operations)',
        '  DGN-001  Diagnostics Module (monitoring)',
        '',
        '═══════════════════════════════════════════════════════════',
      ].join('\n'),
    }))

    this.addChild(opLocalDocs, this.mknode('qsm001.txt', 'file', {
      owner: 'operator', group: 'operator',
      content: [
        '═══════════════════════════════════════════════════════════',
        '  QSM-001 :: QUANTUM STATE MONITOR',
        '  Device Specification v1.2',
        '═══════════════════════════════════════════════════════════',
        '',
        'OVERVIEW',
        '  127-qubit quantum coherence monitor with real-time wave',
        '  function visualization. Tracks entanglement state,',
        '  coherence percentage, error rates, and cryogenic temp.',
        '',
        'SPECIFICATIONS',
        '  Device ID:     QSM-001',
        '  Firmware:      v1.2.0 (build 2026.01.20)',
        '  Checksum:      Q7S4M1N9',
        '  Qubit Array:   127 qubits (IBM Eagle topology)',
        '  Coherence:     T2 ~ 120μs',
        '  Error Correct: Surface code, distance 3',
        '  Cryogenics:    15°K dilution refrigerator',
        '',
        'POWER',
        '  Full:          12 E/s',
        '  Idle:          7 E/s',
        '  Standby:       1 E/s',
        '  Scan/Test:     18 E/s',
        '  Category:      Medium',
        '  Priority:      P2',
        '',
        'FEATURES',
        '  - qubit-array        : 127-qubit register',
        '  - coherence-tracking : Real-time T2 measurement',
        '  - entanglement-verify: Bell state fidelity check',
        '  - error-correction   : Surface code decoder',
        '  - wave-function      : Animated |ψ⟩ display',
        '',
        'COMMANDS',
        '  qsm status           Show quantum state',
        '  qsm power [on|off]   Power on/off',
        '  qsm firmware         View firmware info',
        '  qsm firmware update  Check for updates',
        '  qsm test             Run quantum diagnostics',
        '  qsm reset            Reboot quantum monitor',
        '  qsm info             Show this documentation',
        '',
        'BOOT SEQUENCE',
        '  1. cooling    - Cool qubit array to 15°K',
        '  2. calibrate  - Calibrate qubit frequencies',
        '  3. entangle   - Establish Bell pairs',
        '  4. stabilize  - Error correction init',
        '  5. ready      - Monitor online',
        '',
        'SHUTDOWN SEQUENCE',
        '  1. collapse   - Collapse quantum states',
        '  2. decohere   - Allow decoherence',
        '  3. cooldown   - Thermal stabilization',
        '',
        'TROUBLESHOOTING',
        '  - Low coherence: check cryogenic system temperature',
        '  - No entanglement: run qsm test to verify Bell states',
        '  - High error rate: reboot with qsm reset',
        '  - If display frozen: run qsm power off, then qsm power on',
        '',
        'COMPATIBLE DEVICES',
        '  QAN-001  Quantum Analyzer (quantum operations)',
        '  SCA-001  Supercomputer Array (classical control)',
        '  AIC-001  AI Assistant Core (error optimization)',
        '',
        '═══════════════════════════════════════════════════════════',
      ].join('\n'),
    }))

    this.addChild(opLocalDocs, this.mknode('qua001.txt', 'file', {
      owner: 'operator', group: 'operator',
      content: [
        '═══════════════════════════════════════════════════════════',
        '  QUA-001 :: QUANTUM ANALYZER',
        '  Device Specification v3.7',
        '═══════════════════════════════════════════════════════════',
        '',
        'OVERVIEW',
        '  Universal problem solver with 6 analysis modes,',
        '  neural network processing, waveform generation,',
        '  and deep scan capability.',
        '',
        'SPECIFICATIONS',
        '  Device ID:     QUA-001 (QAN-001)',
        '  Firmware:      v3.7.2 (build 2026.01.29)',
        '  Checksum:      Q7A3N5X8',
        '  Manufacturer:  QNTX Corporation',
        '  Analysis Modes: ANOMALY, RESOURCE, DECRYPT,',
        '                  DIAGNOSE, SIMULATE, SCAN',
        '',
        'POWER',
        '  Full:          25 E/s',
        '  Idle:          10 E/s',
        '  Standby:       2 E/s',
        '  Analysis:      35 E/s',
        '  Category:      Heavy',
        '  Priority:      P2',
        '',
        'FEATURES',
        '  - quantum-core     : Quantum processing engine',
        '  - neural-network   : Pattern recognition & analysis',
        '  - multi-mode       : 6 analysis mode support',
        '  - waveform-gen     : Real-time waveform display',
        '  - deep-scan        : Sub-surface object detection',
        '',
        'COMMANDS',
        '  qua status              Show analyzer status',
        '  qua power [on|off]      Power on/standby',
        '  qua firmware            View firmware info',
        '  qua firmware update     Check for firmware updates',
        '  qua test                Run diagnostics',
        '  qua reset               Reboot analyzer',
        '  qua mode <MODE>         Set analysis mode',
        '  qua sensitivity <0-100> Set sensitivity knob',
        '  qua depth <0-100>       Set depth knob',
        '  qua frequency <0-100>   Set frequency knob',
        '  qua info                Show this documentation',
        '',
        'BOOT SEQUENCE',
        '  1. core       - Initialize quantum core',
        '  2. sensors    - Calibrate sensor array',
        '  3. neural     - Load neural network',
        '  4. calibrate  - System calibration',
        '  5. ready      - Analyzer online',
        '',
        'SHUTDOWN SEQUENCE',
        '  1. save       - Save analysis state',
        '  2. release    - Release resources',
        '  3. offline    - Power down',
        '',
        'ANALYSIS MODES',
        '  ANOMALY   - Detect & classify dimensional anomalies',
        '  RESOURCE  - Optimize resource allocation & yield',
        '  DECRYPT   - Decode encrypted signals & data',
        '  DIAGNOSE  - System health & fault detection',
        '  SIMULATE  - Run predictive simulations',
        '  SCAN      - Deep scan for hidden objects',
        '',
        'COMPATIBLE DEVICES',
        '  EMC-001  Exotic Matter Containment (anomaly source)',
        '  QSM-001  Quantum State Monitor (quantum feed)',
        '  SCA-001  Supercomputer Array (compute offload)',
        '',
        '═══════════════════════════════════════════════════════════',
      ].join('\n'),
    }))

    this.addChild(opLocalDocs, this.mknode('screwbuttons.txt', 'file', {
      owner: 'operator', group: 'operator',
      content: [
        '═══════════════════════════════════════════════════════════',
        '  SCREW BUTTON SYSTEM :: MULTIPLAYER FEATURES',
        '  System Specification v1.0',
        '═══════════════════════════════════════════════════════════',
        '',
        'OVERVIEW',
        '  Four hidden screw buttons on the terminal bezel provide',
        '  access to collaborative multiplayer features. Long-press',
        '  (2 seconds) a screw to toggle activation.',
        '',
        'BUTTONS',
        '  SB-01  Top-Left      NODE-SYNC       Network Node Sync',
        '  SB-02  Top-Right     POOL-LINK       Mining Pool Linkage',
        '  SB-03  Bottom-Left   MESH-CAST       Memetic Broadcasting',
        '  SB-04  Bottom-Right  QUANTUM-BRIDGE  Dimensional Bridge',
        '',
        'COMMANDS',
        '  screwstat              Overview of all screw buttons',
        '  nodesync [sub]         NODE-SYNC control (SB-01)',
        '  poollink [sub]         POOL-LINK control (SB-02)',
        '  meshcast [sub]         MESH-CAST control (SB-03)',
        '  qbridge  [sub]         QUANTUM-BRIDGE control (SB-04)',
        '',
        'ACTIVATION',
        '  - Long-press screw on bezel (2 seconds)',
        '  - Or use terminal: nodesync enable',
        '  - LED ring: red=charging, amber=activating, green=active',
        '',
        '═══════════════════════════════════════════════════════════',
      ].join('\n'),
    }))

    const opCrystals = this.addChild(opHome, this.mknode('crystals', 'dir', { owner: 'operator', group: 'operator' }))
    this.addChild(opCrystals, this.mknode('.gitkeep', 'file', { owner: 'operator', group: 'operator', content: '' }))
    const opScripts = this.addChild(opHome, this.mknode('scripts', 'dir', { owner: 'operator', group: 'operator' }))
    this.addChild(opScripts, this.mknode('scan.sh', 'file', {
      owner: 'operator', group: 'operator', permissions: 0o755,
      content: '#!/bin/sh\n# Volatility scanner script\necho "Scanning blockchain for TPS data..."\nscan\n',
    }))

    // /home/adm
    const admHome = this.addChild(home, this.mknode('adm', 'dir', { owner: 'adm', group: 'adm', permissions: 0o750 }))
    this.addChild(admHome, this.mknode('.bashrc', 'file', {
      owner: 'adm', group: 'adm',
      content: '# _unOS admin shell config\nexport PS1="\\u@_unLAB:\\w$ "\nexport PATH=/bin:/usr/bin:/sbin\n',
    }))
    this.addChild(admHome, this.mknode('.profile', 'file', {
      owner: 'adm', group: 'adm',
      content: '# adm profile\necho "Welcome, administrator."\n',
    }))
    this.addChild(admHome, this.mknode('notes.txt', 'file', {
      owner: 'adm', group: 'adm',
      content: '# Admin Notes\n- Root escalation via su requires wheel group membership\n- Monitor /var/log/auth.log for unauthorized access\n- Crystal stability reports in /srv/_unLAB/reports/\n',
    }))

    // /srv/_unLAB
    const srv = this.addChild(root, this.mknode('srv', 'dir'))
    const srvLab = this.addChild(srv, this.mknode('_unLAB', 'dir'))
    const srvData = this.addChild(srvLab, this.mknode('data', 'dir'))
    this.addChild(srvData, this.mknode('.gitkeep', 'file', { content: '' }))
    const srvReports = this.addChild(srvLab, this.mknode('reports', 'dir'))
    this.addChild(srvReports, this.mknode('stability.log', 'file', {
      content: '[2026-01-28 00:00:00] Crystal stability check: ALL NOMINAL\n[2026-01-28 00:05:00] Volatility tier: 2 (TPS: 1847)\n',
    }))
    this.addChild(srvLab, this.mknode('config', 'dir'))

    // /usr
    const usr = this.addChild(root, this.mknode('usr', 'dir'))
    const usrBin = this.addChild(usr, this.mknode('bin', 'dir'))
    this.addChild(usrBin, this.mknode('crystal-cli', 'file', { permissions: 0o755, content: '#!/bin/sh\n# Crystal management CLI\n' }))
    const usrLib = this.addChild(usr, this.mknode('lib', 'dir'))
    this.addChild(usrLib, this.mknode('libcrystal.so', 'file', { content: '<binary>' }))
    const usrShare = this.addChild(usr, this.mknode('share', 'dir'))
    const usrDoc = this.addChild(usrShare, this.mknode('doc', 'dir'))
    this.addChild(usrDoc, this.mknode('README', 'file', { content: '_unOS - Unstable Laboratories Operating System\nVersion 2.1.0\n' }))

    // /var
    const varDir = this.addChild(root, this.mknode('var', 'dir'))
    const varLog = this.addChild(varDir, this.mknode('log', 'dir'))
    const varLogUnos = this.addChild(varLog, this.mknode('_unOS', 'dir'))
    this.addChild(varLogUnos, this.mknode('system.log', 'file', {
      content: '[2026-01-28 00:00:00] _unOS kernel initialized\n[2026-01-28 00:00:01] All subsystems online\n',
    }))
    this.addChild(varLogUnos, this.mknode('crystal.log', 'file', {
      content: '[2026-01-28 00:00:02] Crystal data cache loaded\n',
    }))
    this.addChild(varLogUnos, this.mknode('screwbutton.log', 'file', {
      content: '[2026-01-28 00:00:03] ScrewButton subsystem initialized\n[2026-01-28 00:00:03] 4 buttons registered: SB-01, SB-02, SB-03, SB-04\n',
    }))
    this.addChild(varLogUnos, this.mknode('network-sync.log', 'file', {
      content: '[2026-01-28 00:00:04] Network sync daemon started\n[2026-01-28 00:00:05] Awaiting node-sync activation...\n',
    }))
    this.addChild(varLog, this.mknode('auth.log', 'file', {
      permissions: 0o640,
      content: '[2026-01-28 00:00:00] operator logged in from terminal\n',
    }))

    // /tmp
    this.addChild(root, this.mknode('tmp', 'dir', { permissions: 0o1777 }))

    // /root
    this.addChild(root, this.mknode('root', 'dir', { permissions: 0o700 }))

    return root
  }

  resolve(path: string): VirtualNode | null {
    const absPath = this.toAbsolute(path)
    if (absPath === '/') return this.root

    const parts = absPath.split('/').filter(Boolean)
    let current = this.root

    for (const part of parts) {
      if (current.type !== 'dir' || !current.children) return null
      const child = current.children.get(part)
      if (!child) return null
      if (child.type === 'symlink' && child.target) {
        const resolved = this.resolve(child.target)
        if (!resolved) return null
        current = resolved
      } else {
        current = child
      }
    }
    return current
  }

  toAbsolute(path: string): string {
    if (path === '~') return this.getHomeDirForUser()
    if (path.startsWith('~/')) return this.getHomeDirForUser() + path.slice(1)
    if (path.startsWith('/')) return this.normalizePath(path)
    return this.normalizePath(this._cwd + '/' + path)
  }

  private _homeUser: string = 'operator'
  setHomeUser(username: string) {
    this._homeUser = username
  }

  private getHomeDirForUser(): string {
    if (this._homeUser === 'root') return '/root'
    return `/home/${this._homeUser}`
  }

  private normalizePath(path: string): string {
    const parts = path.split('/').filter(Boolean)
    const resolved: string[] = []
    for (const part of parts) {
      if (part === '.') continue
      if (part === '..') {
        resolved.pop()
      } else {
        resolved.push(part)
      }
    }
    return '/' + resolved.join('/')
  }

  checkPermission(node: VirtualNode, user: string, groups: string[], action: 'r' | 'w' | 'x'): boolean {
    if (user === 'root') return true
    const perm = node.permissions
    const bitIndex = action === 'r' ? 2 : action === 'w' ? 1 : 0

    if (node.owner === user) {
      return Boolean((perm >> (6 + bitIndex)) & 1)
    }
    if (groups.includes(node.group)) {
      return Boolean((perm >> (3 + bitIndex)) & 1)
    }
    return Boolean((perm >> bitIndex) & 1)
  }

  formatPermissions(node: VirtualNode): string {
    const typeChar = node.type === 'dir' ? 'd' : node.type === 'symlink' ? 'l' : '-'
    const p = node.permissions
    const bits = [
      (p >> 8) & 1 ? 'r' : '-', (p >> 7) & 1 ? 'w' : '-', (p >> 6) & 1 ? 'x' : '-',
      (p >> 5) & 1 ? 'r' : '-', (p >> 4) & 1 ? 'w' : '-', (p >> 3) & 1 ? 'x' : '-',
      (p >> 2) & 1 ? 'r' : '-', (p >> 1) & 1 ? 'w' : '-', (p >> 0) & 1 ? 'x' : '-',
    ]
    return typeChar + bits.join('')
  }

  ls(path?: string, flags: { long?: boolean; all?: boolean } = {}): string[] {
    const targetPath = path || this._cwd
    const node = this.resolve(targetPath)
    if (!node) return [`ls: cannot access '${targetPath}': No such file or directory`]
    if (node.type !== 'dir') {
      if (flags.long) {
        return [this.formatLongEntry(node)]
      }
      return [node.name]
    }

    const entries = Array.from(node.children!.entries())
      .filter(([name]) => flags.all || !name.startsWith('.'))
      .sort(([a], [b]) => a.localeCompare(b))

    if (entries.length === 0) return []

    if (flags.long) {
      return entries.map(([, child]) => this.formatLongEntry(child))
    }

    return entries.map(([, child]) => {
      if (child.type === 'dir') return `\x1b[36m${child.name}/\x1b[0m`
      if (child.type === 'symlink') return `\x1b[35m${child.name}\x1b[0m`
      if ((child.permissions & 0o111) !== 0) return `\x1b[32m${child.name}\x1b[0m`
      return child.name
    })
  }

  private formatLongEntry(node: VirtualNode): string {
    const perms = this.formatPermissions(node)
    const owner = node.owner.padEnd(10)
    const group = node.group.padEnd(10)
    const size = node.size.toString().padStart(6)
    const date = new Date(node.modified).toLocaleDateString('en-US', { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' })
    const name = node.type === 'dir' ? `\x1b[36m${node.name}/\x1b[0m` :
                 node.type === 'symlink' ? `\x1b[35m${node.name} -> ${node.target}\x1b[0m` :
                 (node.permissions & 0o111) !== 0 ? `\x1b[32m${node.name}\x1b[0m` :
                 node.name
    return `${perms} ${owner} ${group} ${size} ${date} ${name}`
  }

  cd(path: string): string | null {
    const target = path === '-' ? this._previousCwd : path
    const absPath = this.toAbsolute(target)
    const node = this.resolve(absPath)
    if (!node) return `cd: ${path}: No such file or directory`
    if (node.type !== 'dir') return `cd: ${path}: Not a directory`
    this._previousCwd = this._cwd
    this._cwd = absPath
    return null
  }

  pwd(): string {
    return this._cwd
  }

  cat(path: string): string | null {
    const node = this.resolve(path)
    if (!node) return `cat: ${path}: No such file or directory`
    if (node.type === 'dir') return `cat: ${path}: Is a directory`
    return node.content ?? ''
  }

  mkdir(path: string, parents: boolean = false): string | null {
    const absPath = this.toAbsolute(path)
    const parts = absPath.split('/').filter(Boolean)
    let current = this.root

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i]
      if (!current.children) return `mkdir: cannot create '${path}': Not a directory`

      const existing = current.children.get(part)
      if (existing) {
        if (existing.type !== 'dir') return `mkdir: cannot create '${path}': File exists`
        if (i === parts.length - 1 && !parents) return `mkdir: cannot create '${path}': File exists`
        current = existing
      } else {
        if (i < parts.length - 1 && !parents) return `mkdir: cannot create '${path}': No such file or directory`
        const newDir = this.mknode(part, 'dir', { owner: this._homeUser, group: this._homeUser })
        this.addChild(current, newDir)
        current = newDir
      }
    }
    return null
  }

  touch(path: string): string | null {
    const absPath = this.toAbsolute(path)
    const parts = absPath.split('/').filter(Boolean)
    const fileName = parts.pop()
    if (!fileName) return `touch: missing file operand`

    const parentPath = '/' + parts.join('/')
    const parent = this.resolve(parentPath)
    if (!parent) return `touch: cannot touch '${path}': No such file or directory`
    if (parent.type !== 'dir') return `touch: cannot touch '${path}': Not a directory`

    const existing = parent.children!.get(fileName)
    if (existing) {
      existing.modified = Date.now()
      return null
    }

    const file = this.mknode(fileName, 'file', { owner: this._homeUser, group: this._homeUser, content: '' })
    this.addChild(parent, file)
    return null
  }

  rm(path: string, recursive: boolean = false): string | null {
    const absPath = this.toAbsolute(path)
    if (absPath === '/') return `rm: cannot remove '/': Permission denied`

    const parts = absPath.split('/').filter(Boolean)
    const name = parts.pop()
    if (!name) return `rm: missing operand`

    const parentPath = '/' + parts.join('/')
    const parent = this.resolve(parentPath)
    if (!parent || !parent.children) return `rm: cannot remove '${path}': No such file or directory`

    const target = parent.children.get(name)
    if (!target) return `rm: cannot remove '${path}': No such file or directory`
    if (target.type === 'dir' && !recursive) return `rm: cannot remove '${path}': Is a directory (use -r)`
    if (target.type === 'dir' && target.children && target.children.size > 0 && !recursive) {
      return `rm: cannot remove '${path}': Directory not empty`
    }

    parent.children.delete(name)
    return null
  }

  tree(path?: string, depth: number = 3): string[] {
    const targetPath = path || this._cwd
    const node = this.resolve(targetPath)
    if (!node) return [`${targetPath} [error opening dir]`]
    if (node.type !== 'dir') return [node.name]

    const lines: string[] = [targetPath]
    this.buildTree(node, '', depth, lines)
    return lines
  }

  private buildTree(node: VirtualNode, prefix: string, depth: number, lines: string[]): void {
    if (depth <= 0 || node.type !== 'dir' || !node.children) return

    const entries = Array.from(node.children.entries())
      .filter(([name]) => !name.startsWith('.'))
      .sort(([a], [b]) => a.localeCompare(b))

    entries.forEach(([, child], i) => {
      const isLast = i === entries.length - 1
      const connector = isLast ? '└── ' : '├── '
      const name = child.type === 'dir' ? `\x1b[36m${child.name}/\x1b[0m` : child.name
      lines.push(prefix + connector + name)
      if (child.type === 'dir') {
        this.buildTree(child, prefix + (isLast ? '    ' : '│   '), depth - 1, lines)
      }
    })
  }

  stat(path: string): VirtualNode | null {
    return this.resolve(path)
  }

  chmod(path: string, mode: number): string | null {
    const node = this.resolve(path)
    if (!node) return `chmod: cannot access '${path}': No such file or directory`
    node.permissions = mode
    return null
  }

  chown(path: string, owner: string): string | null {
    const node = this.resolve(path)
    if (!node) return `chown: cannot access '${path}': No such file or directory`
    node.owner = owner
    return null
  }

  toJSON(): string {
    return JSON.stringify({
      cwd: this._cwd,
      previousCwd: this._previousCwd,
      homeUser: this._homeUser,
      tree: this.serializeNode(this.root),
    })
  }

  private serializeNode(node: VirtualNode): Record<string, unknown> {
    const obj: Record<string, unknown> = {
      n: node.name,
      t: node.type,
      p: node.permissions,
      o: node.owner,
      g: node.group,
      m: node.modified,
      s: node.size,
    }
    if (node.content !== undefined) obj.c = node.content
    if (node.target) obj.tg = node.target
    if (node.children) {
      const ch: Record<string, unknown> = {}
      for (const [k, v] of node.children) {
        ch[k] = this.serializeNode(v)
      }
      obj.ch = ch
    }
    return obj
  }

  static fromJSON(json: string): VirtualFS {
    const fs = new VirtualFS()
    try {
      const data = JSON.parse(json)
      fs._cwd = data.cwd || '/home/operator'
      fs._previousCwd = data.previousCwd || '/home/operator'
      fs._homeUser = data.homeUser || 'operator'
      if (data.tree) {
        fs.root = fs.deserializeNode(data.tree)
      }
    } catch {
      // Return default FS on parse error
    }
    return fs
  }

  private deserializeNode(obj: Record<string, unknown>): VirtualNode {
    const node: VirtualNode = {
      name: obj.n as string,
      type: obj.t as 'file' | 'dir' | 'symlink',
      permissions: obj.p as number,
      owner: obj.o as string,
      group: obj.g as string,
      modified: obj.m as number,
      size: obj.s as number,
    }
    if (obj.c !== undefined) node.content = obj.c as string
    if (obj.tg) node.target = obj.tg as string
    if (obj.ch) {
      node.children = new Map()
      for (const [k, v] of Object.entries(obj.ch as Record<string, unknown>)) {
        node.children.set(k, this.deserializeNode(v as Record<string, unknown>))
      }
    }
    return node
  }
}
